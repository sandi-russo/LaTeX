\documentclass[a4paper, 12pt]{scrartcl} % Classe KOMA-Script
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsthm} % Per le definizioni
\usepackage{newtxtext, newtxmath} % Font New TX
\usepackage[main=italian, english]{babel}
\usepackage{graphicx}
\usepackage[colorlinks=true, linkcolor=blue, urlcolor=blue, citecolor=green]{hyperref} % Opzioni Hyperref migliorate
\usepackage{listings} % Per il codice
\usepackage{xcolor}     % Per i colori
\usepackage{amsmath}    % Per la matematica (se serve)
%\usepackage{tikz}       % Includo TikZ anche se non usato direttamente qui
%\usetikzlibrary{positioning, decorations.pathreplacing, shapes.geometric, arrows} % Librerie TikZ
\usepackage{caption}    % Per le didascalie
\usepackage{subcaption} % Per sotto-figure/tabelle (se servono)
\usepackage{geometry} % Per i margini
\geometry{a4paper, margin=2.5cm} % Margini come specificato
\usepackage{multirow} % Per tabelle con celle unite
\usepackage{array}      % Per opzioni avanzate array/tabular
\usepackage{float}      % Per migliorare il posizionamento [H]

\theoremstyle{definition}
\newtheorem{definizione}{Definizione}[section] % Definizione numerata per sezione

% Definizione colori per listings (come da specifica)
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Impostazioni globali per listings (come da specifica)
\lstset{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue}\bfseries, % Keywords in grassetto blu
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b, % Posizione caption in basso
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single, % Cornice singola
    rulecolor=\color{black},
}

\lstdefinestyle{cstyle}{
    language=C,
    morekeywords={*, extern, static, void, int, return, printf, include, define, ifndef, endif, pid_t, fork, mkfifo, fopen, fprintf, fscanf, remove, unlink, read, write, open, close, sprintf, perror, exit, wait, FILE, NULL, O_RDONLY, O_WRONLY, O_NONBLOCK, EXIT_FAILURE, errno, struct, typedef, const, char, sizeof} % Aggiunte keyword C comuni, POSIX processes e FIFO
}

\lstdefinestyle{makestyle}{
    language=make,
    keywordstyle=\color{red!80!black}\bfseries, % Diverso colore per Makefile
    morekeywords={*, CC, CFLAGS, LDFLAGS, TARGET, OBJS, SRCS, PHONY, all, clean, check, echo, rm, wildcard, gcc} % Keywords Makefile
}

\begin{document}

% Titolo e autore
\title{Hands-On 15}
\subtitle{Algoritmi Distribuiti: Flooding per Cammini Minimi}
\author{Sandi Russo \\ Corso di Laurea: Scienze Informatiche}
\date{\today}
\maketitle

\newpage
\tableofcontents % Indice dei contenuti
\newpage

\section{Introduzione}
Gli algoritmi distribuiti rappresentano una classe di algoritmi progettati per essere eseguiti su sistemi composti da più processori autonomi che comunicano tra loro scambiandosi messaggi. Questi sistemi sono onnipresenti, dalle reti di computer su larga scala ai sistemi multicore. Una delle sfide fondamentali in questo campo è il calcolo dei cammini minimi in un grafo, dove i nodi del grafo rappresentano i processori e gli archi i canali di comunicazione.
\\ \noindent
Questa relazione si concentra sull'implementazione di un algoritmo distribuito per trovare i cammini minimi da un singolo nodo sorgente a tutti gli altri nodi in un grafo. L'approccio utilizzato è una variante dell'algoritmo di Bellman-Ford, comunemente nota come \textbf{flooding}, dove le informazioni sulla distanza si propagano attraverso la rete in ondate successive. Per simulare un ambiente distribuito su una singola macchina, abbiamo adottato un modello basato su processi POSIX, dove ogni nodo del grafo è rappresentato da un processo figlio distinto. La comunicazione tra i nodi (processi) è realizzata tramite \textbf{named pipes (FIFO)}, che fungono da canali di comunicazione unidirezionali.
\\ \noindent
Un aspetto cruciale di molti algoritmi distribuiti è la \textbf{sincronizzazione}. Per emulare un sistema sincrono, in cui l'algoritmo procede in "round" discreti, è stato introdotto un processo \textbf{master}. Il suo unico scopo è orchestrare l'esecuzione dei processi figli, garantendo che tutti i nodi completino una fase del round (ad esempio, l'invio di messaggi) prima di passare alla fase successiva (l'elaborazione dei messaggi ricevuti). Questa sincronizzazione è implementata utilizzando un meccanismo di barriera basato su FIFO.
\\ \noindent
Verrà presentata la struttura modulare del codice, suddivisa in file per la configurazione (`config.h`), la logica del master (`processo\_master.c`), la logica dei nodi figli (`processo\_figlio.c`), il punto di ingresso principale (`main.c`) e le funzioni di utilità (`utils.c`). L'obiettivo è fornire una spiegazione chiara del funzionamento di ogni componente, analizzando le funzioni chiave, il protocollo di comunicazione e sincronizzazione, e illustrando il comportamento del sistema attraverso l'analisi dell'output atteso, che culmina nella costruzione dell'albero dei cammini minimi.

\section{Definizione del Problema}
Il problema consiste nel calcolare l'albero dei cammini minimi da un nodo sorgente designato (la "radice", che nel nostro caso sarà il Nodo 1) a tutti gli altri nodi in un grafo orientato e non pesato. Un "cammino minimo" è definito come il percorso con il minor numero di archi (o "salti").
\\ \noindent
L'implementazione deve aderire ai seguenti vincoli e requisiti, tipici di un sistema distribuito:
\begin{itemize}
    \item \textbf{Modello Distribuito:} L'algoritmo deve essere implementato come un insieme di processi concorrenti, dove ogni processo rappresenta un nodo del grafo.
    \item \textbf{Conoscenza Locale:} Ogni processo-nodo possiede solo informazioni locali: il proprio ID, la sua attuale stima della distanza minima dalla radice, il suo attuale "padre" nel cammino minimo, e l'elenco dei suoi vicini immediati (a cui può inviare messaggi e da cui può riceverne). La topologia globale del grafo non è nota a nessun singolo nodo.
    \item \textbf{Comunicazione via Messaggi:} I processi-nodo possono comunicare esclusivamente scambiandosi messaggi attraverso canali predefiniti, che corrispondono agli archi del grafo. Nel nostro caso, questi canali sono implementati come named pipes (FIFO).
    \item \textbf{Esecuzione Sincrona:} L'algoritmo deve procedere in round discreti e sincronizzati. Un processo master deve garantire che nessun nodo inizi il round $k+1$ prima che tutti i nodi abbiano completato il round $k$. Ogni round è ulteriormente suddiviso in una fase di invio di messaggi e una fase di ricezione/elaborazione, anch'esse sincronizzate.
\end{itemize}
L'obiettivo finale è che, alla terminazione dell'algoritmo, ogni processo-nodo abbia determinato la sua distanza minima dalla radice e l'ID del nodo vicino che funge da suo genitore nel cammino minimo. Il programma principale dovrà quindi raccogliere queste informazioni e ricostruire e visualizzare l'intero albero dei cammini minimi.

\section{Metodologia}
La soluzione è stata sviluppata in linguaggio C su un sistema POSIX-compatibile, sfruttando processi e named pipes (FIFO) per simulare un sistema distribuito. La metodologia si articola su tre pilastri: l'algoritmo di flooding, l'architettura dei processi (master-slave) e il meccanismo di comunicazione e sincronizzazione.

\subsection{Algoritmo di Flooding}
L'algoritmo si basa su un principio iterativo simile a quello di Bellman-Ford. Ogni nodo `i` mantiene due variabili di stato principali: `distanza\_minima\_i` (la lunghezza del cammino più breve conosciuto dalla radice a `i`) e `parent\_i` (il vicino che si trova su tale cammino).
\begin{enumerate}
    \item \textbf{Inizializzazione:} La radice (Nodo 1) imposta la sua distanza a 0 e il suo genitore a se stessa. Tutti gli altri nodi inizializzano la loro distanza a infinito e il genitore a un valore nullo.
    \item \textbf{Round Sincroni:} L'algoritmo procede per un numero di round pari al diametro del grafo più uno (per garanzia di convergenza). Ogni round consiste in due fasi sincrone:
    \begin{itemize}
        \item \textbf{Fase di Invio (msg):} Ogni nodo che ha migliorato la propria distanza nel round precedente invia un messaggio a tutti i suoi vicini uscenti. Il messaggio contiene la sua nuova distanza minima dalla radice. Questo "inonda" la rete con le informazioni aggiornate.
        \item \textbf{Fase di Elaborazione (stf - State Transition Function):} Ogni nodo ascolta i messaggi in arrivo dai suoi vicini entranti. Per ogni messaggio ricevuto da un vicino `j` con distanza `d\_j`, il nodo calcola una distanza potenziale `d\_j + 1`. Se questa distanza è inferiore alla sua `distanza\_minima` attuale, aggiorna la sua distanza e imposta il suo `parent` a `j`.
    \end{itemize}
\end{enumerate}
Dopo `DIAMETRO + 1` round, ogni nodo avrà scoperto il suo cammino minimo dalla radice.

\subsection{Architettura Master-Slave}
Il sistema è composto da un processo \textbf{master} e `NUM\_NODI` processi \textbf{figli} (o slave).
\begin{itemize}
    \item \textbf{Processo Master (`processo\_master.c`):} Il suo unico ruolo è la sincronizzazione. Non partecipa all'algoritmo di calcolo. Utilizza due FIFO principali, `FIFO\_MASTER` e `FIFO\_CODA`, per implementare una barriera. Per avviare una fase, scrive un segnale (un singolo carattere) su `FIFO\_MASTER` per ogni figlio. Successivamente, attende di leggere un messaggio di conferma da ogni figlio su `FIFO\_CODA`. Solo quando tutte le conferme sono arrivate, la fase è considerata conclusa e il master può avviare la successiva.
    \item \textbf{Processo Figlio (`processo\_figlio.c`):} Ogni figlio esegue la logica di un nodo del grafo. Inizialmente, apre le FIFO per comunicare con i suoi vicini. Poi, entra nel ciclo principale dei round, dove attende i segnali di sincronizzazione dal master per eseguire le fasi `msg` e `stf`. Al termine della simulazione, scrive il suo risultato (la coppia `id, parent`) su un file condiviso (`Dati\_figli.txt`).
\end{itemize}

\subsection{Comunicazione e Sincronizzazione}
\begin{itemize}
    \item \textbf{Canali del Grafo (FIFO):} La comunicazione tra nodi avviene tramite FIFO dedicate. Per ogni arco orientato da un nodo `A` a un nodo `B` nel grafo, viene creata una FIFO nominata (es. `fifo\_FROM\_A\_TO\_B`). Il nodo `A` aprirà questa FIFO in scrittura, mentre `B` la aprirà in lettura. Per evitare deadlock durante l'apertura delle FIFO (poiché l'apertura in scrittura blocca finché non c'è un lettore e viceversa), il master sincronizza anche la fase di setup, garantendo che tutti i nodi aprano prima i loro canali di lettura e solo dopo i loro canali di scrittura.
    \item \textbf{Sincronizzazione dei Round:} La funzione `orchestra\_fase` nel master e la funzione `attendi\_e\_segnala` nel figlio implementano la barriera. Il master invia un segnale specifico per ogni fase (es. 'R' per Read-setup, 'W' per Write-setup, 'S' per Send, 'P' per Process), e i figli attendono quel segnale specifico prima di procedere e inviare una conferma al termine.
\end{itemize}
Infine, la compilazione del progetto modulare è gestita da un `Makefile`, che automatizza la creazione dei file oggetto e il linking finale per produrre un singolo eseguibile.

\section{Presentazione dei Risultati}
In questa sezione, analizziamo il codice sorgente di ciascun modulo e discutiamo il suo ruolo nell'architettura complessiva della simulazione.

\subsection{File di Configurazione e Utilità}
Il file `config.h` centralizza tutte le costanti, le strutture dati e i prototipi di funzione, garantendo coerenza tra i vari moduli.

\begin{lstlisting}[style=cstyle, caption={Codice sorgente config.h (Configurazione Globale)}, label={lst:config_h}]
#ifndef CONFIG_H
#define CONFIG_H

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>

#define NUM_NODI 6
#define DIAMETRO 3
#define INFINITO (NUM_NODI + 1)

#define FIFO_MASTER "fifo_master"
#define FIFO_CODA "fifo_coda"
#define FIFO_PATH_FORMAT "fifo_FROM_%d_TO_%d"

typedef struct {
    int id_mittente_originario; // radice (sempre 1)
    int distanza; // distanza tra mittente e radice
} Messaggio;

// Matrice di adiacenza del grafo
extern int grafo[NUM_NODI][NUM_NODI];

void processo_master();
void processo_figlio(int id_nodo);
void msg(int mio_id, int distanza_da_inviare, int fds_scrittura[NUM_NODI]);
void stf(int mio_id, int *parent, int *distanza_minima, int *stato_cambiato, int fds_lettura[NUM_NODI]);
void die(const char *s);

#endif // CONFIG_H
\end{lstlisting}
\noindent
Questo header definisce parametri cruciali come `NUM\_NODI` e `DIAMETRO`, i nomi delle FIFO di sincronizzazione e il formato per quelle di comunicazione. Definisce la struct `Messaggio` usata per la comunicazione tra nodi e dichiara la matrice di adiacenza `grafo` come `extern` per renderla accessibile da tutti i file sorgente che includono l'header, pur essendo definita in un solo punto (`main.c`). Infine, elenca i prototipi di tutte le funzioni principali.

\begin{lstlisting}[style=cstyle, caption={Codice sorgente utils.c (Funzioni di Utilità)}, label={lst:utils_c}]
#include "config.h"
// lo utilizzo per stampare errori e terminare il programma
void die(const char *s) {
    perror(s);
    exit(1);
}
\end{lstlisting}
\noindent
Il file `utils.c` contiene la semplice ma fondamentale funzione `die`, utilizzata in tutto il progetto per gestire errori critici in modo pulito, stampando un messaggio di errore e terminando l'esecuzione.

\subsection{Processo Principale (main.c)}
Il file `main.c` è il punto d'ingresso del programma. È responsabile della definizione della topologia del grafo, della creazione e pulizia delle FIFO, della creazione dei processi figli e dell'avvio del processo master.

\begin{lstlisting}[style=cstyle, caption={Codice sorgente main.c (Orchestrazione Generale)}, label={lst:main_c}]
#include "config.h"

int grafo[NUM_NODI][NUM_NODI] = {
    {0, 1, 1, 1, 0, 0}, // 1 -> 2, 3, 4
    {0, 0, 1, 1, 1, 0}, // 2 -> 3, 4, 5
    {0, 0, 0, 1, 1, 0}, // 3 -> 4, 5
    {0, 0, 0, 0, 0, 0}, // 4 -> nessuno
    {1, 0, 0, 0, 0, 1}, // 5 -> 1, 6
    {0, 0, 0, 1, 1, 0}  // 6 -> 4, 5
};

void crea_fifo() {
    unlink(FIFO_MASTER); if (mkfifo(FIFO_MASTER, 0666) == -1) die("mkfifo master");
    unlink(FIFO_CODA); if (mkfifo(FIFO_CODA, 0666) == -1) die("mkfifo coda");
    char nome_fifo[25];
    for (int i = 0; i < NUM_NODI; ++i) {
        for (int j = 0; j < NUM_NODI; ++j) {
            if (grafo[i][j] == 1) {
                sprintf(nome_fifo, FIFO_PATH_FORMAT, i + 1, j + 1);
                unlink(nome_fifo);
                if (mkfifo(nome_fifo, 0666) == -1) die("mkfifo canale");
            }
        }
    }
}
void pulisci_fifo() {
    unlink(FIFO_MASTER); unlink(FIFO_CODA);
    char nome_fifo[25];
    for (int i = 0; i < NUM_NODI; ++i) {
        for (int j = 0; j < NUM_NODI; ++j) {
            if (grafo[i][j] == 1) { sprintf(nome_fifo, FIFO_PATH_FORMAT, i + 1, j + 1); unlink(nome_fifo); }
        }
    }
}

void mostra_risultati() {
    printf("\n--- Albero dei Cammini Minimi dalla Radice (Nodo 1) ---\n");
    FILE *f = fopen("Dati_figli.txt", "r");
    if (!f) { die("Impossibile leggere il file dei risultati"); }

    int parents[NUM_NODI];
    int id_figlio, id_padre;

    // inizializzo l'array dei padri
    for (int i = 0; i < NUM_NODI; ++i) { parents[i] = -1; }

    // Leggo le coppie (figlio, padre) dal file e popola l'array
    while (fscanf(f, "%d %d\n", &id_figlio, &id_padre) == 2) {
        if (id_figlio > 0 && id_figlio <= NUM_NODI) {
            parents[id_figlio - 1] = id_padre;
        }
    }
    fclose(f);

    // itera su ogni nodo per stamparne il percorso
    for (int i = 0; i < NUM_NODI; ++i) { // i e' l'indice (0-based)
        printf("Percorso per Nodo %d: ", i + 1);

        if (parents[i] == -1) {
            printf("Non raggiungibile\n");
            continue;
        }

        int percorso[NUM_NODI];
        int len = 0;
        int curr_idx = i;

        // Ricostruisci il percorso all'indietro
        while (curr_idx != -1) {
            percorso[len++] = curr_idx + 1; // salva il numero del nodo
            if (curr_idx + 1 == parents[curr_idx]) break; // qui arriviamo alla radice
            curr_idx = parents[curr_idx] - 1; // va all'indice del padre
        }

        for (int j = len - 1; j >= 0; --j) { // lo uso per la stampa del percorso
            printf("%d%s", percorso[j], (j > 0) ? " -> " : "\n");
        }
    }
    remove("Dati_figli.txt");
}

int main() {
    pid_t pids[NUM_NODI];
    remove("Dati_figli.txt");
    printf("Creazione delle FIFO...\n");
    crea_fifo();
    printf("Creazione dei processi figli (Nodi)...\n");
    for (int i = 0; i < NUM_NODI; ++i) {
        pids[i] = fork();
        if (pids[i] < 0) die("fork");
        if (pids[i] == 0) { processo_figlio(i + 1); exit(0); }
    }
    printf("Avvio del processo Master...\n");
    processo_master();
    printf("Master ha terminato. In attesa dei figli...\n");
    for (int i = 0; i < NUM_NODI; ++i) { wait(NULL); }
    printf("Tutti i figli hanno terminato.\n");
    mostra_risultati();
    printf("Pulizia delle FIFO...\n");
    pulisci_fifo();
    return 0;
}
\end{lstlisting}
\noindent
Il `main` definisce la matrice `grafo`, che rappresenta la topologia della rete. Il suo flusso è lineare: pulisce eventuali file di output residui, crea tutte le FIFO necessarie, esegue un ciclo `fork` per generare i `NUM\_NODI` processi figli (ciascuno dei quali invocherà `processo\_figlio`), dopodiché il processo genitore originale assume il ruolo di master invocando `processo\_master`. Una volta che il master ha finito di sincronizzare i round, il genitore attende la terminazione di tutti i figli con `wait`. Infine, chiama `mostra\_risultati` per leggere il file di output `Dati\_figli.txt`, ricostruire i percorsi e stamparli, per poi terminare pulendo le FIFO.

\subsection{Processo Master (`processo\_master.c`)}
Questo modulo contiene la logica del processo di sincronizzazione, che agisce come un direttore d'orchestra per i nodi.

\begin{lstlisting}[style=cstyle, caption={Codice sorgente processo\_master.c (Logica di Sincronizzazione)}, label={lst:master}]
#include "config.h"

void orchestra_fase(const char* nome_fase, char segnale) {
    // invio il segnale di avvio della fase a tutti i nodi
    int fifo_master_fd = open(FIFO_MASTER, O_WRONLY);
    if (fifo_master_fd < 0) die("master: open fifo_master");
    for (int i = 0; i < NUM_NODI; ++i) {
        if (write(fifo_master_fd, &segnale, sizeof(char)) != sizeof(char)) {
            perror("master: write segnale");
        }
    }
    close(fifo_master_fd);

    // attendo la conferma da parte di tutti i nodi
    int fifo_coda_fd = open(FIFO_CODA, O_RDONLY);
    if (fifo_coda_fd < 0) die("master: open fifo_coda");
    int nodi_completati = 0;
    int id_nodo_letto;
    while (nodi_completati < NUM_NODI) {
        if (read(fifo_coda_fd, &id_nodo_letto, sizeof(int)) == sizeof(int)) {
            nodi_completati++;
        }
    }
    close(fifo_coda_fd);
    printf("MASTER: Fase '%s' completata da tutti i nodi.\n", nome_fase);
}

void processo_master() {
    orchestra_fase("Apertura Canali di Lettura", 'R');
    orchestra_fase("Apertura Canali di Scrittura", 'W');

   // Loop per i round
    int round_totali = DIAMETRO + 1;
    for (int round = 1; round <= round_totali; ++round) {
        printf("\n--- MASTER: Inizio Round %d ---\n", round);
        orchestra_fase("Invio Messaggi", 'S');     // 'S' per Send
        orchestra_fase("Elaborazione Messaggi", 'P'); // 'P' per Process
    }
}
\end{lstlisting}
\noindent
La funzione chiave qui è `orchestra\_fase`. Essa implementa una barriera di sincronizzazione: prima invia un segnale a tutti i figli attraverso `FIFO\_MASTER`, poi si mette in attesa su `FIFO\_CODA` finché non ha ricevuto una conferma da ciascuno dei `NUM\_NODI` figli. La funzione `processo\_master` utilizza `orchestra\_fase` per scandire l'intera simulazione: prima le due fasi di setup per l'apertura delle FIFO, poi un ciclo che per ogni round orchestra la fase di invio ('S') e quella di elaborazione ('P').

\subsection{Processo Figlio (`processo\_figlio.c`)}
Questo è il cuore dell'algoritmo distribuito, dove viene eseguita la logica di ciascun nodo.

\begin{lstlisting}[style=cstyle, caption={Codice sorgente processo\_figlio.c (Logica del Nodo)}, label={lst:figlio_c}]
#include "config.h"

void msg(int mio_id, int distanza_da_inviare, int fds_scrittura[NUM_NODI]) {
    Messaggio m = {1, distanza_da_inviare};
    printf("NODO %d [msg]: Propago la mia distanza migliore (%d).\n", mio_id, m.distanza);
    for (int i = 0; i < NUM_NODI; ++i) {
        if (grafo[mio_id - 1][i] == 1 && fds_scrittura[i] != -1) {
            write(fds_scrittura[i], &m, sizeof(Messaggio));
        }
    }
}

void stf(int mio_id, int *parent, int *distanza_minima, int *stato_cambiato, int fds_lettura[NUM_NODI]) {
    Messaggio m;
    *stato_cambiato = 0;
    for (int i = 0; i < NUM_NODI; ++i) {
        if (grafo[i][mio_id - 1] == 1 && fds_lettura[i] != -1) {
            int mittente_immediato = i + 1;
            while (read(fds_lettura[i], &m, sizeof(Messaggio)) > 0) {
                int distanza_proposta = m.distanza + 1;
                if (distanza_proposta < *distanza_minima) {
                    printf("NODO %d [stf]: CAMMINO MIGLIORE trovato via NODO %d! Distanza %d -> %d\n", mio_id, mittente_immediato, *distanza_minima, distanza_proposta);
                    *distanza_minima = distanza_proposta;
                    *parent = mittente_immediato;
                    *stato_cambiato = 1;
                }
            }
        }
    }
}

void attendi_e_segnala(int id_nodo, char segnale_atteso) {
    char received_signal;
    int fifo_master_fd = open(FIFO_MASTER, O_RDONLY);
    if(fifo_master_fd < 0) die("figlio: open fifo_master");

    if (read(fifo_master_fd, &received_signal, sizeof(char)) < 0) {
        die("figlio: read from fifo_master");
    }

    if(received_signal != segnale_atteso){
        fprintf(stderr, "ERRORE DI SINCRONIZZAZIONE: Nodo %d si aspettava '%c' ma ha ricevuto '%c'\n", id_nodo, segnale_atteso, received_signal);
        exit(EXIT_FAILURE);
    }

    close(fifo_master_fd);

    int fifo_coda_fd = open(FIFO_CODA, O_WRONLY);
    if(fifo_coda_fd < 0) die("figlio: open fifo_coda");
    write(fifo_coda_fd, &id_nodo, sizeof(int));
    close(fifo_coda_fd);
}

void processo_figlio(int id_nodo) {
    int parent = -1;
    int distanza_minima = INFINITO;
    int stato_cambiato = 0;

    if (id_nodo == 1) { parent = 1; distanza_minima = 0; stato_cambiato = 1; }

    int fds_lettura[NUM_NODI], fds_scrittura[NUM_NODI];
    for (int i = 0; i < NUM_NODI; ++i) { fds_lettura[i] = -1; fds_scrittura[i] = -1; }

    attendi_e_segnala(id_nodo, 'R');
    for (int i = 0; i < NUM_NODI; ++i) { if (grafo[i][id_nodo - 1] == 1) { char n[30]; sprintf(n, FIFO_PATH_FORMAT, i + 1, id_nodo); fds_lettura[i] = open(n, O_RDONLY | O_NONBLOCK); } }
    attendi_e_segnala(id_nodo, 'W');
    for (int j = 0; j < NUM_NODI; ++j) { if (grafo[id_nodo - 1][j] == 1) { char n[30]; sprintf(n, FIFO_PATH_FORMAT, id_nodo, j + 1); fds_scrittura[j] = open(n, O_WRONLY); } }
-
    for (int round = 1; round <= DIAMETRO + 1; ++round) {
        attendi_e_segnala(id_nodo, 'S');
        if (stato_cambiato) {
            msg(id_nodo, distanza_minima, fds_scrittura);
        }
        attendi_e_segnala(id_nodo, 'P');
        stf(id_nodo, &parent, &distanza_minima, &stato_cambiato, fds_lettura);
    }


    for (int i = 0; i < NUM_NODI; ++i) { if (fds_lettura[i] != -1) close(fds_lettura[i]); if (fds_scrittura[i] != -1) close(fds_scrittura[i]); }
    FILE *f = fopen("Dati_figli.txt", "a");
    if (f) {
        fprintf(f, "%d %d\n", id_nodo, parent);
        fclose(f);
    }
}
\end{lstlisting}
\noindent
Il `processo\_figlio` inizializza il suo stato (distanza e genitore; la radice ha valori speciali). La funzione `attendi\_e\_segnala` è il complemento di `orchestra\_fase`: attende un segnale dal master su `FIFO\_MASTER` e invia una conferma su `FIFO\_CODA`. Il flusso principale del figlio segue esattamente le fasi dettate dal master: attende il segnale 'R', apre i canali di lettura; attende 'W', apre i canali di scrittura. Poi entra nel ciclo dei round: attende 'S', esegue `msg` (se il suo stato è cambiato); attende 'P', esegue `stf` per aggiornare il suo stato in base ai messaggi ricevuti. Al termine, chiude tutti i file descriptor e appende il suo risultato (la coppia `id, parent`) al file `Dati\_figli.txt`.

\subsection{Makefile}
Infine, il `Makefile` gestisce la compilazione di tutti i moduli in un unico eseguibile.

\begin{lstlisting}[style=makestyle, caption={Makefile per la Compilazione del Progetto}, label={lst:makefile}]
# Makefile per il progetto Flooding

# Definisce il compilatore C da utilizzare
CC = gcc
# Definisce i flag da passare al compilatore
CFLAGS = -g -Wall
# Definisce il nome dell'eseguibile finale
TARGET = flooding_sim

# Elenco dei file oggetto (.o) necessari
OBJS = main.o processo_master.o processo_figlio.o utils.o

# Regola di default: 'all' dipende dall'eseguibile
all: $(TARGET)

# Regola per creare l'eseguibile: collega tutti i file oggetto
$(TARGET): $(OBJS)
	$(CC) $(CFLAGS) -o $@ $^

# Regola Pattern per compilare un file sorgente .c in un file oggetto .o
# Ogni .o dipende dal suo .c e dall'header comune 'config.h'
%.o: %.c config.h
	$(CC) $(CFLAGS) -c $< -o $@

# Regola 'clean': rimuove i file generati
clean:
	rm -f $(OBJS) $(TARGET) Dati_figli.txt
	@echo "File compilati e di output rimossi."

# Dichiarazione di target 'PHONY'
.PHONY: all clean
\end{lstlisting}
\noindent
Questo `Makefile` definisce le variabili per il compilatore (`CC`), i flag (`CFLAGS`), il nome dell'eseguibile (`TARGET`) e l'elenco dei file oggetto (`OBJS`). La regola `all` costruisce il target. La regola di linking `$(TARGET): $(OBJS)` unisce tutti i file `.o`. La regola pattern `%.o: %.c config.h` è fondamentale: definisce come compilare qualsiasi file `.c` in un file `.o` (con `-c`), specificando che ogni file oggetto dipende non solo dal suo sorgente ma anche da `config.h`, assicurando una ricompilazione corretta se l'header viene modificato. La regola `clean` rimuove tutti i file generati, incluso il file di output `Dati_figli.txt`.

\subsubsection{Output Atteso e Discussione}
Eseguendo `./flooding\_sim` dopo la compilazione con `make`, l'output mostrerà la sequenza di operazioni. Inizialmente, si vedranno i messaggi di setup da `main`. Poi, l'output del master scandirà l'esecuzione, annunciando l'inizio e la fine di ogni fase e di ogni round. Tra i messaggi del master, appariranno in modo non deterministico i log dei processi figli, in particolare i messaggi `[stf]: CAMMINO MIGLIORE...` che indicano la convergenza dell'algoritmo.
\\ \noindent
L'output finale e più importante è quello generato dalla funzione `mostra\_risultati`, che avrà un aspetto simile a questo:

\begin{verbatim}
Percorso per Nodo 1: 1
Percorso per Nodo 2: 1 -> 2
Percorso per Nodo 3: 1 -> 3
Percorso per Nodo 4: 1 -> 4
Percorso per Nodo 5: 1 -> 2 -> 5
Percorso per Nodo 6: 1 -> 2 -> 5 -> 6
\end{verbatim}
\noindent
Questo risultato dimostra che l'algoritmo ha calcolato correttamente i cammini più brevi dalla radice (Nodo 1) a tutti gli altri nodi, ricostruendo l'albero dei cammini minimi basandosi sulle relazioni padre-figlio scoperte da ciascun nodo in modo distribuito. L'output conferma il successo della simulazione e la correttezza dell'algoritmo di flooding implementato.

\section{Conclusioni}
Questo progetto ha permesso di implementare e analizzare con successo una simulazione di un algoritmo distribuito per il calcolo dei cammini minimi, basato sul principio del flooding. Attraverso l'uso di processi POSIX e named pipes (FIFO), è stato possibile modellare un sistema di nodi concorrenti che comunicano scambiandosi messaggi, riflettendo le condizioni di un vero sistema distribuito.
\\ \noindent
L'architettura \textbf{master-slave} si è rivelata una soluzione efficace per emulare un'esecuzione \textbf{sincrona}, un requisito fondamentale per molti algoritmi distribuiti basati su round. Il master, agendo come un semplice orchestratore, ha permesso di separare nettamente la logica di sincronizzazione da quella algoritmica, eseguita interamente dai processi figli. Questo ha migliorato la modularità e la chiarezza del codice.
\\ \noindent
La gestione della comunicazione tramite \textbf{FIFO} ha messo in luce alcune delle sfide pratiche della programmazione inter-processo, come la necessità di evitare deadlock durante l'inizializzazione dei canali di comunicazione, risolta attraverso una fase di setup sincronizzata. L'uso di un file header comune (`config.h`) e di un `Makefile` ha rafforzato le buone pratiche di sviluppo, garantendo manutenibilità e facilità di compilazione.
\\ \noindent
In conclusione, l'esercizio ha fornito una comprensione pratica e approfondita dei concetti chiave della programmazione distribuita: la gestione dello stato locale, la comunicazione basata su messaggi, e l'importanza critica della sincronizzazione. La soluzione sviluppata non solo risolve correttamente il problema posto, ma costituisce anche un modello robusto e scalabile per la simulazione di altri algoritmi distribuiti sincroni.

\end{document}