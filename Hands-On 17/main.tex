\documentclass[a4paper, 12pt]{scrartcl} % Classe KOMA-Script
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsthm} % Per le definizioni
\usepackage{newtxtext, newtxmath} % Font New TX
\usepackage[main=italian, english]{babel}
\usepackage{graphicx}
\usepackage[colorlinks=true, linkcolor=blue, urlcolor=blue, citecolor=green]{hyperref} % Opzioni Hyperref migliorate
\usepackage{listings} % Per il codice
\usepackage{xcolor}     % Per i colori
\usepackage{amsmath}    % Per la matematica (se serve)
%\usepackage{tikz}       % Includo TikZ anche se non usato direttamente qui
%\usetikzlibrary{positioning, decorations.pathreplacing, shapes.geometric, arrows} % Librerie TikZ
\usepackage{caption}    % Per le didascalie
\usepackage{subcaption} % Per sotto-figure/tabelle (se servono)
\usepackage{geometry} % Per i margini
\geometry{a4paper, margin=2.5cm} % Margini come specificato
\usepackage{multirow} % Per tabelle con celle unite
\usepackage{array}      % Per opzioni avanzate array/tabular
\usepackage{float}      % Per migliorare il posizionamento [H]

\theoremstyle{definition}
\newtheorem{definizione}{Definizione}[section] % Definizione numerata per sezione

% Definizione colori per listings (come da specifica)
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Impostazioni globali per listings (come da specifica)
\lstset{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue}\bfseries, % Keywords in grassetto blu
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b, % Posizione caption in basso
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single, % Cornice singola
    rulecolor=\color{black},
}

\lstdefinestyle{cstyle}{
    language=C,
    morekeywords={*, extern, static, void, int, return, printf, include, define, ifndef, endif, pid_t, fork, mkfifo, fopen, fprintf, fscanf, remove, unlink, read, write, open, close, sprintf, perror, exit, wait, FILE, NULL, O_RDONLY, O_WRONLY, O_NONBLOCK, EXIT_FAILURE, errno, struct, typedef, const, char, sizeof} % Aggiunte keyword C comuni, POSIX processes e FIFO
}

\lstdefinestyle{makestyle}{
    language=make,
    keywordstyle=\color{red!80!black}\bfseries, % Diverso colore per Makefile
    morekeywords={*, CC, CFLAGS, LDFLAGS, TARGET, OBJS, SRCS, PHONY, all, clean, check, echo, rm, wildcard, gcc} % Keywords Makefile
}

\begin{document}

% Titolo e autore
\title{Hands-On 17}
\subtitle{Algoritmo di Bellman-Ford Distribuito}
\author{Sandi Russo \\ Corso di Laurea: Scienze Informatiche}
\date{9 giugno 2025}
\maketitle

\newpage
\tableofcontents % Indice dei contenuti
\newpage

\section{Introduzione}
Il calcolo dei cammini minimi da una singola sorgente (Single-Source Shortest Path) è un problema classico e fondamentale nella teoria dei grafi e nell'informatica, con applicazioni che vanno dal routing di rete alla logistica. Mentre algoritmi come Dijkstra sono molto efficienti per grafi con pesi non negativi, l'algoritmo di \textbf{Bellman-Ford} offre una soluzione più generale, capace di gestire anche grafi con archi di peso negativo. La sua natura iterativa, basata su un'operazione di "rilassamento" ripetuta, si presta particolarmente bene a un'implementazione distribuita.
\\ \noindent
Questa relazione documenta l'implementazione di una versione distribuita e sincrona dell'algoritmo di Bellman-Ford. Per simulare un ambiente distribuito, ogni nodo del grafo è rappresentato da un processo POSIX autonomo. La comunicazione tra questi nodi avviene esclusivamente attraverso lo scambio di messaggi su canali dedicati, implementati tramite \textbf{named pipes (FIFO)}. L'esecuzione dell'algoritmo è scandita in round sincroni, la cui temporizzazione è gestita da un processo \textbf{master} che agisce da coordinatore. Questo garantisce che tutti i nodi completino un'iterazione dell'algoritmo prima di procedere alla successiva, mimando il comportamento di un sistema distribuito sincrono.
\\ \noindent
Verrà analizzata la struttura del codice, suddiviso in moduli per una maggiore chiarezza: la configurazione globale (`config.h`), la logica del processo master (`processo\_master.c`), quella dei processi figli che implementano i nodi (`processo\_figlio.c`), il punto di ingresso del programma (`main.c`) e le funzioni di utilità (`utils.c`). L'obiettivo è illustrare come l'operazione di rilassamento di Bellman-Ford venga tradotta in un protocollo di comunicazione a messaggi e come il sistema converga, dopo un numero predefinito di round, alla soluzione corretta.

\section{Definizione del Problema}
Il problema consiste nell'implementare una versione distribuita dell'algoritmo di Bellman-Ford per trovare i cammini di costo minimo da un singolo nodo sorgente a tutti gli altri nodi in un grafo orientato e \textbf{pesato}. Il costo di un cammino è dato dalla somma dei pesi degli archi che lo compongono.
\\ \noindent
L'implementazione deve rispettare i seguenti requisiti architetturali e algoritmici:
\begin{itemize}
    \item \textbf{Modello Distribuito:} Il sistema è composto da `N` processi, dove `N` è il numero di nodi del grafo. Ogni processo simula il comportamento di un singolo nodo, possedendo solo conoscenza locale.
    \item \textbf{Grafo Pesato:} A differenza delle precedenti implementazioni basate su flooding, qui gli archi hanno un costo (peso) associato, che deve essere considerato nel calcolo della distanza.
    \item \textbf{Algoritmo di Bellman-Ford:} La logica di ogni nodo deve implementare l'operazione di \textit{rilassamento} (relax). Per ogni arco entrante `(u, v)`, il nodo `v` deve verificare se il percorso che passa per `u` offre una distanza minore dalla sorgente.
    \item \textbf{Esecuzione Sincrona a Round:} L'algoritmo deve procedere per `N-1` round. Un processo master deve sincronizzare l'inizio e la fine di ogni round, garantendo che tutti i nodi eseguano le loro operazioni in modo coordinato.
    \item \textbf{Comunicazione via Messaggi:} I processi-nodo comunicano solo tramite FIFO. I messaggi scambiati contengono le informazioni necessarie per l'operazione di rilassamento, ovvero la stima della distanza del nodo mittente dalla sorgente.
\end{itemize}
L'obiettivo finale è che, al termine dei `N-1` round, ogni processo-nodo abbia determinato la propria distanza minima dalla sorgente e il proprio "genitore" nell'albero dei cammini minimi. Il programma principale dovrà quindi raccogliere e visualizzare l'albero risultante.

\section{Metodologia}
La soluzione si basa sulla traduzione diretta dell'algoritmo di Bellman-Ford in un modello a processi e messaggi, utilizzando l'infrastruttura di sincronizzazione master-slave già sviluppata.

\subsection{Algoritmo di Bellman-Ford Distribuito}
L'algoritmo si fonda sul principio del rilassamento iterativo. Ogni nodo `v` mantiene una stima `d[v]` della sua distanza dalla sorgente e un puntatore `p[v]` al suo predecessore nel cammino minimo.
\begin{enumerate}
    \item \textbf{Inizializzazione:} Il nodo sorgente `s` imposta `d[s] = 0` e `p[s] = s`. Tutti gli altri nodi `v` impostano `d[v] = INFINITO` e `p[v] = NULL`.
    \item \textbf{Round di Rilassamento:} L'algoritmo esegue `N-1` round, dove `N` è il numero totale di nodi. È garantito che, in assenza di cicli di peso negativo, dopo `N-1` iterazioni l'algoritmo converge alle distanze corrette. Ogni round è diviso in due fasi sincrone:
    \begin{itemize}
        \item \textbf{Fase di Invio (msg):} A differenza delle varianti ottimizzate, nella versione classica di Bellman-Ford implementata qui, \textbf{tutti i nodi}, in ogni round, inviano un messaggio a tutti i loro vicini uscenti. Il messaggio contiene la stima corrente della propria distanza dalla sorgente (`d[v]`).
        \item \textbf{Fase di Elaborazione (stf - Relax):} Ogni nodo `v` ascolta i messaggi in arrivo dai suoi vicini entranti. Per ogni messaggio ricevuto da un vicino `u` con distanza `d[u]`, il nodo `v` esegue l'operazione di rilassamento: calcola la distanza proposta `d[u] + peso(u,v)` e, se questa è inferiore alla sua stima attuale `d[v]`, aggiorna `d[v]` al nuovo valore e imposta `p[v] = u`.
    \end{itemize}
\end{enumerate}
Dopo `N-1` round, il processo termina. Se fosse necessario rilevare cicli negativi, si potrebbe eseguire un ulteriore round e verificare se le distanze migliorano ancora.

\subsection{Architettura del Sistema}
L'architettura rimane quella master-slave, dimostrandosi adatta anche a questo algoritmo.
\begin{itemize}
    \item \textbf{Processo Master (`processo\_master.c`):} Il suo compito è far rispettare la sequenza di `N-1` round. Per ogni round, invia un segnale 'S' per la fase di invio e un segnale 'P' per la fase di elaborazione (rilassamento), attendendo il completamento di tutti i figli prima di procedere. Al termine dei round, invia un segnale di terminazione 'Q'.
    \item \textbf{Processo Figlio (`processo\_figlio.c`):} Simula un nodo del grafo. Inizializza il suo stato e poi entra nel ciclo principale di `N-1` round. Ad ogni round, attende i segnali dal master, esegue le funzioni `msg` e `stf`, e infine attende il segnale 'Q' per terminare e scrivere il suo risultato (la coppia `id, parent`) su un file condiviso.
    \item \textbf{Comunicazione e Strutture Dati:} I canali di comunicazione sono FIFO. Per rappresentare il grafo pesato, vengono utilizzate due matrici globali: una matrice di adiacenza `grafo` e una matrice `pesi`. Il `Messaggio` scambiato tra i nodi è stato semplificato per contenere solo la `distanza\_mittente`.
\end{itemize}
La compilazione del progetto è gestita da un `Makefile` standardizzato.

\section{Presentazione dei Risultati}
Analizziamo ora i componenti chiave del codice che implementano la simulazione dell'algoritmo di Bellman-Ford.

\subsection{File di Configurazione e Utilità}
Il file `config.h` definisce le costanti, la struttura del messaggio e i prototipi di funzione, adattati per un grafo pesato.

\begin{lstlisting}[style=cstyle, caption={Codice sorgente config.h (Configurazione Globale)}, label={lst:config_h}]
#ifndef CONFIG_H
#define CONFIG_H

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>

#define NUM_NODI 4
#define SORGENTE 0
#define INFINITO (9999)

#define FIFO_MASTER "fifo_master"
#define FIFO_CODA "fifo_coda"
#define FIFO_PATH_FORMAT "fifo_FROM_%d_TO_%d"

typedef struct {
    int distanza_mittente;
} Messaggio;

extern int grafo[NUM_NODI][NUM_NODI];
extern int pesi[NUM_NODI][NUM_NODI];

void processo_master();
void processo_figlio(int id_nodo);
void msg(int mio_id, int distanza, int fds_scrittura[NUM_NODI]);
void stf(int mio_id, int *parent, int *distanza_minima, int *stato_cambiato, int fds_lettura[NUM_NODI]);
void die(const char *s);

#endif
\end{lstlisting}
\noindent
In `config.h`, si notano due dichiarazioni `extern` per le matrici `grafo` e `pesi`, indicando che la topologia e i costi del grafo sono definiti altrove. La costante `SORGENTE` è impostata a 0, stabilendo un'identificazione dei nodi 0-based. La `struct Messaggio` è minimale e contiene solo la distanza del mittente, l'unica informazione necessaria per l'operazione di rilassamento.

\begin{lstlisting}[style=cstyle, caption={Codice sorgente utils.c (Funzioni di Utilità)}, label={lst:utils_c}]
#include "config.h"

void die(const char *s) {
    perror(s);
    exit(1);
}
\end{lstlisting}
\noindent
Il file `utils.c` è invariato e fornisce la funzione `die` per una gestione pulita degli errori.

\subsection{Processo Principale (main.c)}
Il file `main.c` definisce il grafo, crea i processi e gestisce il ciclo di vita della simulazione.

\begin{lstlisting}[style=cstyle, caption={Codice sorgente main.c (Orchestrazione Generale)}, label={lst:main_c}]
#include "config.h"

int grafo[NUM_NODI][NUM_NODI] = {
    {0, 1, 0, 1},
    {0, 0, 1, 0},
    {1, 1, 0, 0},
    {0, 0, 1, 0}
};

int pesi[NUM_NODI][NUM_NODI] = {
    {0, 6, 0, 1},
    {0, 0, 1, 0},
    {3, 2, 0, 0},
    {0, 0, 2, 0}
};

void crea_fifo() {
    unlink(FIFO_MASTER); if (mkfifo(FIFO_MASTER, 0666) == -1) die("mkfifo master");
    unlink(FIFO_CODA); if (mkfifo(FIFO_CODA, 0666) == -1) die("mkfifo coda");
    char nome_fifo[25];
    for (int i = 0; i < NUM_NODI; ++i) {
        for (int j = 0; j < NUM_NODI; ++j) {
            if (grafo[i][j] == 1) {
                sprintf(nome_fifo, FIFO_PATH_FORMAT, i, j);
                unlink(nome_fifo);
                if (mkfifo(nome_fifo, 0666) == -1) die("mkfifo canale");
            }
        }
    }
}
void pulisci_fifo() {
    unlink(FIFO_MASTER); unlink(FIFO_CODA);
    char nome_fifo[25];
    for (int i = 0; i < NUM_NODI; ++i) {
        for (int j = 0; j < NUM_NODI; ++j) {
            if (grafo[i][j] == 1) { sprintf(nome_fifo, FIFO_PATH_FORMAT, i, j); unlink(nome_fifo); }
        }
    }
}

void mostra_risultati() {
    printf("\n--- Albero dei Cammini Minimi dalla Sorgente (Nodo %d) ---\n", SORGENTE);
    FILE *f = fopen("Dati_figli.txt", "r");
    if (!f) { die("Impossibile leggere il file dei risultati"); }
    int parents[NUM_NODI];
    for (int i = 0; i < NUM_NODI; ++i) { parents[i] = -1; }
    int id_figlio, id_padre;
    while (fscanf(f, "%d %d\n", &id_figlio, &id_padre) == 2) {
        if (id_figlio >= 0 && id_figlio < NUM_NODI) { parents[id_figlio] = id_padre; }
    }
    fclose(f);
    for (int i = 0; i < NUM_NODI; ++i) {
        if (i == SORGENTE) { printf("Percorso per Nodo %d: %d (Sorgente)\n", i, i); continue; }
        printf("Percorso per Nodo %d: ", i);
        if (parents[i] == -1) { printf("Non raggiungibile\n"); continue; }
        int percorso[NUM_NODI], len = 0, curr_idx = i;
        while (curr_idx != -1) {
            percorso[len++] = curr_idx;
            if (curr_idx == parents[curr_idx]) break;
            curr_idx = parents[curr_idx];
        }
        for (int j = len - 1; j >= 0; --j) { printf("%d%s", percorso[j], (j > 0) ? " -> " : "\n"); }
    }
    remove("Dati_figli.txt");
}

int main() {
    pid_t pids[NUM_NODI];
    remove("Dati_figli.txt");
    crea_fifo();
    for (int i = 0; i < NUM_NODI; ++i) {
        pids[i] = fork();
        if (pids[i] < 0) die("fork");
        if (pids[i] == 0) { processo_figlio(i); exit(0); }
    }
    processo_master();
    for (int i = 0; i < NUM_NODI; ++i) { wait(NULL); }
    mostra_risultati();
    pulisci_fifo();
    printf("\nSimulazione completata.\n");
    return 0;
}
\end{lstlisting}
\noindent
Questo file definisce concretamente le matrici `grafo` e `pesi` che rappresentano il grafo pesato della simulazione. La funzione `main` orchestra il flusso standard: pulizia, creazione delle FIFO e dei processi figli (passando ID 0-based), avvio del master, attesa dei figli, visualizzazione dei risultati e pulizia finale.

\subsection{Processo Master (`processo\_master.c`)}
Il master è stato leggermente adattato per eseguire esattamente `N-1` round e inviare un segnale di terminazione.

\begin{lstlisting}[style=cstyle, caption={Codice sorgente processo\_master.c (Logica di Sincronizzazione)}, label={lst:master_c}]
#include "config.h"

void orchestra_fase(const char* nome_fase, char segnale) {
    int fifo_master_fd = open(FIFO_MASTER, O_WRONLY);
    if (fifo_master_fd < 0) die("master: open fifo_master");
    for (int i = 0; i < NUM_NODI; ++i) {
        if (write(fifo_master_fd, &segnale, sizeof(char)) != sizeof(char)) {
            perror("master: write segnale");
        }
    }
    close(fifo_master_fd);

    int fifo_coda_fd = open(FIFO_CODA, O_RDONLY);
    if (fifo_coda_fd < 0) die("master: open fifo_coda");
    int nodi_completati = 0;
    while (nodi_completati < NUM_NODI) {
        int id_nodo_letto;
        if (read(fifo_coda_fd, &id_nodo_letto, sizeof(int)) == sizeof(int)) {
            nodi_completati++;
        }
    }
    close(fifo_coda_fd);
    printf("MASTER: Fase '%s' completata da tutti i nodi.\n", nome_fase);
}

void processo_master() {
    orchestra_fase("Apertura Canali", 'R');
    orchestra_fase("Conferma Apertura Canali", 'W');

    printf("\n--- MASTER: Setup completato. Inizio algoritmo Bellman-Ford ---\n");

    int round_totali = NUM_NODI - 1;
    for (int round = 1; round <= round_totali; ++round) {
        printf("\n--- MASTER: Inizio Round %d/%d ---\n", round, round_totali);
        orchestra_fase("Invio Messaggi", 'S');
        orchestra_fase("Elaborazione Messaggi (Relax)", 'P');
    }
    orchestra_fase("Terminazione", 'Q');
}
\end{lstlisting}
\noindent
La logica del `processo\_master` è chiara. Dopo le fasi di setup, esegue un ciclo per `NUM\_NODI - 1` volte, che è il numero di iterazioni richieste da Bellman-Ford per garantire la convergenza. Ad ogni iterazione, orchestra le fasi di invio ('S') e di rilassamento ('P'). Infine, invia un segnale di terminazione 'Q' per consentire ai processi figli di uscire in modo pulito dai loro cicli.

\subsection{Processo Figlio (`processo\_figlio.c`)}
Questo modulo contiene l'implementazione distribuita del cuore dell'algoritmo di Bellman-Ford.

\begin{lstlisting}[style=cstyle, caption={Codice sorgente processo\_figlio.c (Logica del Nodo - Bellman-Ford)}, label={lst:figlio_c}]
#include "config.h"

void msg(int mio_id, int distanza, int fds_scrittura[NUM_NODI]) {
    Messaggio m = {distanza};
    for (int i = 0; i < NUM_NODI; ++i) {
        if (grafo[mio_id][i] == 1 && fds_scrittura[i] != -1) {
            write(fds_scrittura[i], &m, sizeof(Messaggio));
        }
    }
}

void stf(int mio_id, int *parent, int *distanza_minima, int *stato_cambiato, int fds_lettura[NUM_NODI]) {
    Messaggio m;
    *stato_cambiato = 0;
    for (int i = 0; i < NUM_NODI; ++i) {
        if (grafo[i][mio_id] == 1 && fds_lettura[i] != -1) {
            int mittente_immediato = i;
            while (read(fds_lettura[i], &m, sizeof(Messaggio)) > 0) {
                if (m.distanza_mittente == INFINITO) continue;

                int distanza_proposta = m.distanza_mittente + pesi[mittente_immediato][mio_id];

                if (distanza_proposta < *distanza_minima) {
                    printf("NODO %d [stf]: CAMMINO MIGLIORE via NODO %d! Distanza %d -> %d\n", mio_id, mittente_immediato, *distanza_minima, distanza_proposta);
                    *distanza_minima = distanza_proposta;
                    *parent = mittente_immediato;
                    *stato_cambiato = 1;
                }
            }
        }
    }
}

void attendi_e_segnala(int id_nodo, char segnale_atteso) {
    char received_signal;
    int fifo_master_fd = open(FIFO_MASTER, O_RDONLY);
    if(fifo_master_fd < 0) die("figlio: open fifo_master");
    if (read(fifo_master_fd, &received_signal, sizeof(char)) < 0) die("figlio: read from fifo_master");
    if(received_signal != segnale_atteso) { fprintf(stderr, "ERRORE DI SINCRONIZZAZIONE: Nodo %d\n", id_nodo); exit(EXIT_FAILURE); }
    close(fifo_master_fd);
    int fifo_coda_fd = open(FIFO_CODA, O_WRONLY);
    if(fifo_coda_fd < 0) die("figlio: open fifo_coda");
    write(fifo_coda_fd, &id_nodo, sizeof(int));
    close(fifo_coda_fd);
}

void processo_figlio(int id_nodo) {
    int parent = -1;
    int distanza_minima = INFINITO;
    int stato_cambiato = 1;

    if (id_nodo == SORGENTE) { parent = SORGENTE; distanza_minima = 0; }

    int fds_lettura[NUM_NODI], fds_scrittura[NUM_NODI];
    for (int i = 0; i < NUM_NODI; ++i) { fds_lettura[i] = -1; fds_scrittura[i] = -1; }

    attendi_e_segnala(id_nodo, 'R');
    for (int i = 0; i < NUM_NODI; ++i) { if (grafo[i][id_nodo] == 1) { char n[30]; sprintf(n, FIFO_PATH_FORMAT, i, id_nodo); fds_lettura[i] = open(n, O_RDONLY | O_NONBLOCK); } }
    attendi_e_segnala(id_nodo, 'W');
    for (int j = 0; j < NUM_NODI; ++j) { if (grafo[id_nodo][j] == 1) { char n[30]; sprintf(n, FIFO_PATH_FORMAT, id_nodo, j); fds_scrittura[j] = open(n, O_WRONLY); } }

    int round_totali = NUM_NODI - 1;
    for (int round = 1; round <= round_totali; ++round) {
        attendi_e_segnala(id_nodo, 'S');
        msg(id_nodo, distanza_minima, fds_scrittura);

        attendi_e_segnala(id_nodo, 'P');
        stf(id_nodo, &parent, &distanza_minima, &stato_cambiato, fds_lettura);
    }

    attendi_e_segnala(id_nodo, 'Q');

    FILE *f = fopen("Dati_figli.txt", "a");
    if (f) { fprintf(f, "%d %d\n", id_nodo, parent); fclose(f); }
}
\end{lstlisting}
\noindent
La logica in `processo\_figlio.c` è una fedele traduzione dell'algoritmo. La funzione `stf` è centrale: per ogni messaggio ricevuto da un vicino `i`, calcola la `distanza\_proposta` sommando la distanza del mittente con il peso dell'arco che li collega (`pesi[mittente\_immediato][mio\_id]`). Questa è l'operazione di rilassamento. Se il nuovo percorso è migliore, lo stato del nodo (distanza e genitore) viene aggiornato. In `processo\_figlio`, la chiamata a `msg` è incondizionata all'interno del ciclo dei round, riflettendo la natura dell'algoritmo classico di Bellman-Ford in cui tutti i nodi partecipano a ogni fase di rilassamento.

\subsection{Makefile}
Il `Makefile` rimane una utility standard per la compilazione del progetto.

\begin{lstlisting}[style=makestyle, caption={Makefile per la Compilazione del Progetto}, label={lst:makefile}]
# Makefile per il progetto Bellman-Ford

CC = gcc
CFLAGS = -g -Wall
TARGET = bellman_ford_sim

OBJS = main.o processo_master.o processo_figlio.o utils.o

all: $(TARGET)

$(TARGET): $(OBJS)
	$(CC) $(CFLAGS) -o $@ $^

%.o: %.c config.h
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	rm -f $(OBJS) $(TARGET) Dati_figli.txt
	@echo "File compilati e di output rimossi."

.PHONY: all clean
\end{lstlisting}
\noindent
L'unica modifica rilevante nel `Makefile` è il nome del `TARGET`, impostato a \\`bellman\_ford\_sim` per descrivere accuratamente l'eseguibile prodotto.

\subsubsection{Output Atteso e Discussione}
Eseguendo `./bellman\_ford\_sim`, la console mostrerà i log del master che scandisce i `N-1=3` round. I processi figli stamperanno messaggi `[stf]: CAMMINO MIGLIORE...` ogni volta che un'operazione di rilassamento avrà successo, migliorando la stima della distanza di un nodo.
\\ \noindent
L'output finale, stampato da `mostra\_risultati` dopo la convergenza dell'algoritmo, sarà il seguente:

\begin{verbatim}
Percorso per Nodo 0: 0 (Sorgente)
Percorso per Nodo 1: 0 -> 3 -> 2 -> 1
Percorso per Nodo 2: 0 -> 3 -> 2
Percorso per Nodo 3: 0 -> 3

Simulazione completata.
\end{verbatim}
\noindent
Questo output mostra i percorsi di costo minimo dalla sorgente (Nodo 0) a tutti gli altri nodi. Ad esempio, il percorso verso il Nodo 1 non è il diretto `0 -> 1` (costo 6), ma il più economico `0 -> 3 -> 2 -> 1` (costo 1 + 2 + 2 = 5). Questo dimostra che l'algoritmo ha esplorato correttamente le alternative e ha trovato le soluzioni ottimali, confermando il successo dell'implementazione distribuita di Bellman-Ford.

\section{Conclusioni}
L'implementazione di un algoritmo di Bellman-Ford distribuito ha permesso di esplorare con successo i meccanismi alla base del calcolo dei cammini minimi in grafi pesati. L'architettura basata su processi e FIFO si è dimostrata ancora una volta un modello efficace per la simulazione di sistemi distribuiti sincroni.
\\ \noindent
Il punto focale del progetto è stata la traduzione dell'operazione di \textbf{rilassamento} in un protocollo di messaggistica. La metodologia ha evidenziato come ogni nodo, con la sua conoscenza puramente locale, possa contribuire al calcolo globale semplicemente scambiando la propria stima di distanza e aggiornandola in base alle informazioni ricevute. La garanzia di convergenza in `N-1` round, un pilastro teorico di Bellman-Ford, ha trovato una diretta applicazione nella struttura del ciclo principale di master e figli.
\\ \noindent
La separazione tra la topologia del grafo (`grafo`) e i suoi costi (`pesi`) ha reso il codice più chiaro e più vicino alle rappresentazioni teoriche. L'uso di un processo master per la sincronizzazione ha permesso di concentrare la logica algoritmica nei processi figli, mantenendo il sistema modulare e comprensibile.
\\ \noindent
In conclusione, questo esercizio ha consolidato la comprensione degli algoritmi distribuiti sincroni, dimostrando come un concetto algoritmico classico quale Bellman-Ford possa essere efficacemente mappato su un'architettura concorrente a processi, ottenendo una soluzione corretta e robusta.

\end{document}