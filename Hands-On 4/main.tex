\documentclass[a4paper, 12pt]{scrartcl}
\usepackage[utf8]{inputenc} % supporto caratteri UTF-8
\usepackage[T1]{fontenc} % migliore gestione dei font
\usepackage{newtxtext, newtxmath} % Font Times New Roman-like
\usepackage[main=italian, english]{babel} % imposta l'italiano come lingua principale
\usepackage{graphicx} % per l'inserimento di immagini
\usepackage{hyperref} % per link nell'indice
\usepackage{listings} % per codice sorgente
\usepackage{xcolor} % per colorare il codice
\usepackage{amsmath} % per formule matematiche complesse

% formattazione codice sorgente
\lstset{
    language=C,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    breaklines=true,
    frame=single,
    captionpos=b
}

% informazioni sulla relazione
\title{Hands-On 4}
\subtitle{MULTIPLEXING I/O CON EPOLL}
\author{Sandi Russo \\ Corso di Laurea: Scienze Informatiche} % Nome e CdL
\date{\today}

\begin{document}

\maketitle % Genera la copertina con titolo, sottotitolo e autore

\newpage
\tableofcontents % Inserisce l'indice automatico
\newpage

\section{Introduzione}
In questo documento verrà presentato un server TCP multi-client implementato in linguaggio C. Questo server è in grado di gestire più client simultaneamente senza l'uso di thread o processi separati. Utilizza la funzione \textit{epoll()} per monitorare più socket e gestire la comunicazione con i client. Il server è progettato per essere non bloccante, permettendo una gestione efficiente delle connessioni in tempo reale.
\noindent
Lo scopo di questa documentazione è fornire una spiegazione dettagliata di come funziona il server, come è stato implementato e come si comporta durante l'esecuzione, con esempi pratici.

\section{Definizione del Problema}
Il problema da risolvere è quello di creare un server che possa gestire più connessioni client contemporaneamente in modo efficiente e senza l'uso di thread o processi separati. Tradizionalmente, i server che devono supportare più client simultaneamente adottano un modello basato su multithreading o multiprocessing, assegnando un thread o un processo dedicato a ciascuna connessione. Tuttavia, questo approccio presenta alcune limitazioni significative, come l'elevato consumo di risorse di sistema e la complessità nella gestione della concorrenza e della sincronizzazione tra i vari thread o processi.
\noindent
Per superare queste problematiche, si desidera implementare un server che utilizzi un modello di programmazione concorrente basato su operazioni di I/O non bloccanti. In particolare, il codice sfrutta la funzione \textit{epoll()}, che consente di monitorare simultaneamente molteplici socket e rilevare quali di essi siano pronti per operazioni di lettura o scrittura. Questo approccio permette di ottimizzare l'utilizzo delle risorse e garantire una gestione efficiente delle connessioni, evitando il sovraccarico legato alla creazione e alla gestione di molteplici thread o processi.

\section{Metodologia}
La metodologia utilizzata nel codice è la seguente:
\begin{itemize}
    \item Creazione di un socket TCP per il server.
    \item Impostazione del socket del server come non bloccante per evitare che l'esecuzione del programma si fermi in attesa di nuove connessioni o dati.
    \item Utilizzo della funzione \textit{epoll()} per monitorare più socket simultaneamente.
    \item Gestione delle connessioni e dei dati ricevuti dai client.
    \item Gestione della disconnessione dei client e rimozione dei loro socket dalla lista.
\end{itemize}

\newpage
\section{Creazione del Socket del Server e Configurazione}
La prima parte del codice riguarda la creazione del socket del server, l'assegnazione dell'indirizzo e della porta e la messa in ascolto del socket. 

\begin{lstlisting}[caption={Creazione del socket del server}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/epoll.h>

#define PORT 8080
#define BUFFER_SIZE 256
#define MAX_EVENTS 10

// Funzione per impostare un socket come non bloccante
void set_nonblocking(int sockfd) {
    int flags = fcntl(sockfd, F_GETFL, 0);  // Otteniamo lo stato attuale del file descriptor

    /*
     fcntl => File Control
     F_SETFL, vogliamo modificare le opzioni del file descriptor
     O_NONBLOCK, impostiamo il socket come non bloccante
    */
    fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
}

int main() {

    /*
    sockfd, descrittore del socket del server
    newsockfd, descrittore del socket che viene usato per i client
    epollfd, descrittore del file che viene creato dal server per monitorare gli eventi
    */
    int sockfd, newsockfd, epollfd;
    struct sockaddr_in serv_addr, cli_addr; // strutture per gli indirizzi del server e del client
    socklen_t clilen = sizeof(cli_addr); // calcolo la lunghezza dell'indirizzo del client
    char buffer[BUFFER_SIZE]; // lo utilizzo per memorizzare i dati inviati e ricevuti dai client
    struct epoll_event ev, events[MAX_EVENTS]; // eventi da monitorare per epoll e il numero massimo
    
    // array per tenere traccia dei socket client connessi
    int client_sockets = 0;

    /*
    creo la socket con AF_INET per gli IPV4 e uso SOCK_STREAM per impostarla TCP
    */
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) { // se non riesce a creare la socket, restituisce un errore
        perror("socket fallito");
        exit(EXIT_FAILURE);
    }

    // Configura l'indirizzo del server
    serv_addr.sin_family = AF_INET; // imposto la tipologia IPV4
    serv_addr.sin_addr.s_addr = INADDR_ANY; // accetta connessioni da qualsiasi interfaccia e indirizzo
    serv_addr.sin_port = htons(PORT); // specifico la porta ed utilizzo htons per la conversione in formato di rete

    // collego la socket appena creata all'indirizzo ip tramite la bind
    if (bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        perror("bind fallito"); // se non riesce ad effettuare l'unione, stampa un errore
        exit(EXIT_FAILURE);
    }

    // metto la socket in ascolto con una coda di attesa di 5
    if (listen(sockfd, 5) < 0) {  // se non riesce a mettersi in ascolto, stampa un errore
        perror("listen fallito");
        exit(EXIT_FAILURE);
    }

    set_nonblocking(sockfd);  // imposta il socket come non bloccante
    printf("Server in ascolto sulla porta %d...\n", PORT);

    // creo l'istanza epoll per monitorare gli eventi
    epollfd = epoll_create1(0); // restituisce un FD per l'oggetto o -1 in caso di errore
    if (epollfd == -1) { // se la creazione fallisce, stampo un messaggio di errore
        perror("epoll_create1 fallito");
        exit(EXIT_FAILURE);
    }
    ev.events = EPOLLIN; // monitoriamo gli eventi di lettura
    ev.data.fd = sockfd; // il file descriptor e' il socket del server
    /*
    epoll_ctl serve per aggiungere, rimuovere o modificare i descrittori di file
    qui lo uso per aggiungerli, infatti utilizzo il parametro EPOLL_CTL_ADD
    gli passo epollfd che ho ottenuto dalla create
    il tipo di operazione: aggiunta, rimozione, modifica
    il file descriptor del server che voglio monitorare
    le informazioni sull'evento come EPOLLIN 
    */
    if (epoll_ctl(epollfd, EPOLL_CTL_ADD, sockfd, &ev) == -1) { // se il controllo fallisce, stampo un errore
        perror("epoll_ctl: sockfd fallito");
        exit(EXIT_FAILURE);
    }
}
\end{lstlisting}

\subsection{Spiegazione}
In questa parte del codice:
\begin{itemize}
    \item Viene creato un socket server tramite la chiamata \textit{socket(AF\_INET, SOCK\_STREAM, 0)}. Il tipo \textit{AF\_INET} indica che il server utilizza il protocollo IPv4, mentre \textit{SOCK\_STREAM} specifica che si tratta di un socket TCP.
    \item Il socket viene legato a un indirizzo IP (\textit{INADDR\_ANY}) e a una porta definita nella variabile \textit{PORT}, utilizzando la funzione \textit{bind()}.
    \item Il server viene messo in ascolto per le connessioni in entrata con \textit{listen()}.
    \item Il socket viene configurato come non bloccante con la funzione \textit{set\_nonblocking()}, così che le operazioni di I/O non blocchino l'esecuzione del server.
    \item Viene creato un file descriptor epoll con la funzione \textit{epoll\_create1(0)} per monitorare gli eventi sui socket.
    \item Il socket del server viene aggiunto al set di file descriptor monitorati da epoll con la funzione \textit{epoll\_ctl()}.
    \item Le funzioni di errore come \textit{perror} vengono utilizzate per gestire eventuali errori durante la creazione e la configurazione del socket.
    \item La funzione \textit{htons()} è utilizzata per convertire il numero di porta dal formato host al formato di rete.
    \item L'utilizzo di \textit{fcntl()} per impostare il socket come non bloccante è essenziale per evitare che il server si blocchi durante le operazioni di I/O.
\end{itemize}

\newpage
\section{Monitoraggio dei Socket e Gestione delle Connessioni}
La parte centrale del server è il ciclo che gestisce le connessioni dei client, utilizzando \textit{epoll()} per monitorare più socket in modo concorrente.

\begin{lstlisting}[caption={Monitoraggio dei Socket e Gestione delle Connessioni}]
    while (1) {
        /*
        epoll_wait serve per attendere gli eventi su uno o piu' descrittori di file
        gli passo epollfd
        l'evento che si e' verificato
        il numero massimo di eventi che si desidera ricevere, praticamente, determina la dimensione dell'array di events
        timeout che deve essere in millisecondi, in questo caso e' -1 e significa che la funzione non ha limiti di tempo
        */
        int nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1); 
        if (nfds == -1) { // se fallisce nella ricerca di eventi, stampa un errore
            perror("epoll_wait fallito");
            exit(EXIT_FAILURE);
        }

        // itero su tutti gli eventi che sono pronti per essere gestiti
        for (int n = 0; n < nfds; ++n) {
            // se l'evento riguarda il socket del server, significa che c'e' una nuova connessione
            if (events[n].data.fd == sockfd) {
                // essendo pronto ad una nuova connessione, accetto la connessione e restituisco il nuovo socket con newsockfd
                if ((newsockfd = accept(sockfd, (struct sockaddr *)&cli_addr, &clilen)) < 0) { // se fallisce per un qualsiasi motivo, stampo un errore
                    perror("accept fallito");
                    exit(EXIT_FAILURE);
                }

                set_nonblocking(newsockfd);  // imposta il socket del nuovo client come non bloccante

                // imposto il nuovo socker in lettura degli eventi EPOLLIN
                ev.events = EPOLLIN | EPOLLET;
                ev.data.fd = newsockfd; // il file descriptor e' il socket del client

                // eseguo sul nuovo socket la ctl per aggiungere i descrittori di file
                if (epoll_ctl(epollfd, EPOLL_CTL_ADD, newsockfd, &ev) == -1) { // in caso di errore, stampo un messaggio
                    perror("epoll_ctl: newsockfd fallito");
                    exit(EXIT_FAILURE);
                }
                
                client_sockets++; // se ha funzionato il tutto, incremento il contatore del client e stampo il messaggio di avvenuta connesione
                printf("Nuovo client %d connesso\n", client_sockets);
            } else { // se l'evento riguarda un client gia' connesso
                int client_fd = events[n].data.fd; // ottengo il file descriptor del client
                // uso recv per leggere i dati dalla socket client e se hanno successo li salvo in buffer                
                int n = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);  // riceve i dati dal client
                if (n > 0) {
                    buffer[n] = '\0';  // sfrutto il terminatore di stringa
                    printf("Messaggio ricevuto dal client %d: %s\n", client_sockets, buffer);
                    send(client_fd, "ACK\n", 4, 0); // invia un ACK al client per confermare ricezione
                } else if (n == 0) { // se recv ritorna 0, significa che il client si e' disconnesso
                    printf("Client %d disconnesso\n", client_sockets);
                    close(client_fd);  // chiude il socket del client
                    // questa volta utilizzo ctl per rimuovere la socket dal monitoraggio con EPOLL_CTL_DEL
                    epoll_ctl(epollfd, EPOLL_CTL_DEL, client_fd, NULL);
                } else { // si e' verificato un errore
                    if (errno != EWOULDBLOCK && errno != EAGAIN) {
                        perror("recv fallito");
                        close(client_fd);
                        epoll_ctl(epollfd, EPOLL_CTL_DEL, client_fd, NULL);
                    }
                }
            }
        }
    }

    close(sockfd);
    close(epollfd);
    return 0;
}
\end{lstlisting}

\newpage
\subsection{Spiegazione}
In questa parte del codice:
\begin{itemize}
    \item Il ciclo while monitora continuamente gli eventi sui socket utilizzando \textit{epoll\_wait()}.
    \item Se ci sono nuovi eventi, il codice itera su di essi e gestisce le nuove connessioni o i dati ricevuti dai client esistenti.
    \item Se il socket del server è pronto, accetta una nuova connessione con \textit{accept()} e configura il nuovo socket come non bloccante.
    \item Il nuovo socket viene aggiunto al set di file descriptor monitorati da epoll.
    \item Se un client esistente invia dati, questi vengono letti con \textit{recv()} e viene inviato un ACK al client con \textit{send()}.
    \item Se un client si disconnette, il socket del client viene chiuso e rimosso dal set di file descriptor monitorati.
\end{itemize}

\section{Conclusione}
Il codice implementa un server multi-client TCP che utilizza \textit{epoll()} per gestire più connessioni simultaneamente senza utilizzare thread o processi separati. L'approccio basato su socket non bloccanti e \textit{epoll()} consente di gestire efficientemente le connessioni concorrenti, facendo sì che il server rimanga reattivo durante l'elaborazione delle richieste.
\noindent
In sintesi, l'uso di \textit{epoll()} permette di monitorare più socket in modo semplice ed efficace, senza la necessità di complicate tecniche di gestione della concorrenza come il multithreading. Il codice può essere facilmente esteso per gestire un numero maggiore di client o per integrare funzionalità aggiuntive come la gestione dei timeout o la sicurezza delle connessioni.
\end{document}